diff --git a/shared/bootstrap/diagnostics.go b/shared/bootstrap/diagnostics.go
index e5cdf6e9..5bbbe7b0 100644
--- a/shared/bootstrap/diagnostics.go
+++ b/shared/bootstrap/diagnostics.go
@@ -1,14 +1,19 @@
 package bootstrap
 
 import (
+	"bufio"
 	"context"
 	"crypto/tls"
 	"fmt"
 	"net"
 	"net/http"
 	"net/url"
+	"os"
+	"os/exec"
+	"runtime"
 	"strings"
 	"time"
 )
@@ -77,6 +82,20 @@ func runBootstrapDiagnostics(ctx context.Context, baseURL string, cfg diagnostic
 	if err != nil {
 		result.add("URL", fmt.Sprintf("invalid (%v)", err))
 		return result
 	}
+
+	resolvStatus, resolvServers := resolvConfSummary()
+	if resolvStatus != "" {
+		result.add("Resolver", resolvStatus)
+	}
+	if len(resolvServers) > 0 {
+		result.add("DNS Servers", strings.Join(resolvServers, ", "))
+	}
+	if runtime.GOOS == "android" {
+		if props := androidDNSProps(); len(props) > 0 {
+			result.add("Android DNS", strings.Join(props, ", "))
+		}
+	}
 
 	proxyStatus, proxyURL := proxyDescription(target.url, cfg.disableProxy)
 	result.add("Proxy", proxyStatus)
@@ -205,6 +224,118 @@ func parseDiagnosticTarget(baseURL string) (diagnosticTarget, error) {
 	}, nil
 }
 
+func resolvConfSummary() (string, []string) {
+	contents, path, err := readResolvConf()
+	if err != nil {
+		return "resolv.conf missing", nil
+	}
+	servers := parseResolvConf(contents)
+	if len(servers) == 0 {
+		return fmt.Sprintf("%s (no nameserver entries)", path), nil
+	}
+
+	annotated := make([]string, 0, len(servers))
+	for _, server := range servers {
+		if isLoopback(server) {
+			annotated = append(annotated, server+" (loopback)")
+		} else {
+			annotated = append(annotated, server)
+		}
+	}
+
+	return path, annotated
+}
+
+func readResolvConf() (string, string, error) {
+	candidates := []string{"/etc/resolv.conf"}
+	if prefix := os.Getenv("PREFIX"); prefix != "" {
+		candidates = append(candidates, prefix+"/etc/resolv.conf")
+	}
+
+	for _, path := range candidates {
+		data, err := os.ReadFile(path)
+		if err != nil {
+			continue
+		}
+		return string(data), path, nil
+	}
+
+	return "", "", fmt.Errorf("resolv.conf not found")
+}
+
+func parseResolvConf(contents string) []string {
+	if contents == "" {
+		return nil
+	}
+	servers := []string{}
+	seen := map[string]struct{}{}
+
+	scanner := bufio.NewScanner(strings.NewReader(contents))
+	for scanner.Scan() {
+		line := strings.TrimSpace(scanner.Text())
+		if line == "" || strings.HasPrefix(line, "#") {
+			continue
+		}
+		fields := strings.Fields(line)
+		if len(fields) < 2 || fields[0] != "nameserver" {
+			continue
+		}
+		server := fields[1]
+		if _, ok := seen[server]; ok {
+			continue
+		}
+		seen[server] = struct{}{}
+		servers = append(servers, server)
+	}
+	return servers
+}
+
+func isLoopback(server string) bool {
+	return server == "127.0.0.1" || server == "::1" || strings.HasPrefix(server, "127.0.0.")
+}
+
+func androidDNSProps() []string {
+	props := []string{"net.dns1", "net.dns2", "net.dns3", "net.dns4"}
+	results := []string{}
+	seen := map[string]struct{}{}
+
+	for _, prop := range props {
+		value, err := runGetprop(prop)
+		if err != nil {
+			continue
+		}
+		value = strings.TrimSpace(value)
+		if value == "" {
+			continue
+		}
+		entry := fmt.Sprintf("%s=%s", prop, value)
+		if _, ok := seen[entry]; ok {
+			continue
+		}
+		seen[entry] = struct{}{}
+		results = append(results, entry)
+	}
+
+	return results
+}
+
+func runGetprop(key string) (string, error) {
+	cmd := exec.Command("getprop", key)
+	out, err := cmd.Output()
+	if err != nil {
+		return "", err
+	}
+	return string(out), nil
+}
+
 func defaultPort(scheme string) string {
 	switch strings.ToLower(scheme) {
 	case schemeHTTPS:
