From 51f05936d36802c00fd3d6558c9b0a56ffb07877 Mon Sep 17 00:00:00 2001
From: David Aronchick <aronchick@gmail.com>
Date: Thu, 5 Feb 2026 20:44:36 -0800
Subject: [PATCH] fix: retry bootstrap with fallback DNS on android

---
 shared/bootstrap/client.go       | 115 ++++++++++++++++++++++++++++---
 shared/bootstrap/dns_fallback.go | 101 +++++++++++++++++++++++++++
 shared/http/client.go            | 105 ++++++++++++++++++++++++++--
 shared/http/config.go            |   6 ++
 4 files changed, 312 insertions(+), 15 deletions(-)
 create mode 100644 shared/bootstrap/dns_fallback.go

diff --git a/shared/bootstrap/client.go b/shared/bootstrap/client.go
index 2eab5ca..8c45384 100644
--- a/shared/bootstrap/client.go
+++ b/shared/bootstrap/client.go
@@ -5,6 +5,7 @@ import (
 	stderrors "errors"
 	"fmt"
 	"net/http"
+	"runtime"
 	"strings"
 	"time"
 
@@ -36,9 +37,10 @@ func getContextDeadline(ctx context.Context) string {
 
 // Client handles communication with the bootstrap service
 type Client struct {
-	http *req.Client
-	base string
-	diag diagnosticsConfig
+	http   *req.Client
+	base   string
+	diag   diagnosticsConfig
+	config ClientConfig
 }
 
 // ClientConfig contains configuration for the bootstrap client
@@ -63,6 +65,12 @@ type ClientConfig struct {
 
 	// ForceIPv4 forces IPv4 for bootstrap requests
 	ForceIPv4 bool
+
+	// PreferGoDNS forces the Go DNS resolver for bootstrap requests
+	PreferGoDNS bool
+
+	// DNSServers overrides DNS resolution for bootstrap requests
+	DNSServers []string
 }
 
 // NewClient creates a new bootstrap client
@@ -88,6 +96,8 @@ func NewClient(config ClientConfig) (*Client, error) {
 		InsecureSkipVerify: config.InsecureSkipVerify,
 		DisableProxy:       config.DisableProxy,
 		ForceIPv4:          config.ForceIPv4,
+		PreferGoDNS:        config.PreferGoDNS,
+		DNSServers:         config.DNSServers,
 		Auth: corehttp.AuthConfig{
 			Token: config.Token,
 		},
@@ -109,11 +119,27 @@ func NewClient(config ClientConfig) (*Client, error) {
 			insecureSkipVerify: config.InsecureSkipVerify,
 			timeout:            config.Timeout,
 		},
+		config: config,
 	}, nil
 }
 
 // Bootstrap performs bootstrap with the bootstrap service
 func (c *Client) Bootstrap(ctx context.Context, req *BootstrapRequest) (*BootstrapResponse, error) {
+	response, err := c.bootstrapOnce(ctx, req)
+	if err != nil {
+		if retried, retryErr, attempted := c.retryBootstrapWithDNSFallback(ctx, req, err); attempted {
+			if retryErr != nil {
+				return nil, retryErr
+			}
+			return c.validateBootstrapResponse(retried)
+		}
+		return nil, c.formatBootstrapError(ctx, err)
+	}
+	// Validate response
+	return c.validateBootstrapResponse(response)
+}
+
+func (c *Client) bootstrapOnce(ctx context.Context, req *BootstrapRequest) (*BootstrapResponse, error) {
 	var response BootstrapResponse
 
 	_, err := c.http.R().
@@ -121,14 +147,20 @@ func (c *Client) Bootstrap(ctx context.Context, req *BootstrapRequest) (*Bootstr
 		SetBody(req).
 		SetSuccessResult(&response).
 		Post("/api/v1/register")
-
 	if err != nil {
-		if enhanced := c.enhanceBootstrapError(ctx, err); enhanced != nil {
-			return nil, enhanced
-		}
-		return nil, fmt.Errorf("bootstrap request failed: %w", err)
+		return nil, err
+	}
+
+	return &response, nil
+}
+
+func (c *Client) validateBootstrapResponse(response *BootstrapResponse) (*BootstrapResponse, error) {
+	if response == nil {
+		return nil, errors.New("bootstrap response was empty").
+			WithCode(errors.CodeBadRequest).
+			WithComponent("BootstrapClient").
+			WithHint("The bootstrap service returned an empty response")
 	}
-	// Validate response
 	if response.NodeID == "" {
 		return nil, errors.New("bootstrap response missing client ID").
 			WithCode(errors.CodeBadRequest).
@@ -148,7 +180,70 @@ func (c *Client) Bootstrap(ctx context.Context, req *BootstrapRequest) (*Bootstr
 			WithHint("The bootstrap service returned an incomplete response")
 	}
 
-	return &response, nil
+	return response, nil
+}
+
+func (c *Client) formatBootstrapError(ctx context.Context, err error) error {
+	if enhanced := c.enhanceBootstrapError(ctx, err); enhanced != nil {
+		return enhanced
+	}
+	return fmt.Errorf("bootstrap request failed: %w", err)
+}
+
+func (c *Client) retryBootstrapWithDNSFallback(ctx context.Context, req *BootstrapRequest, err error) (*BootstrapResponse, error, bool) {
+	if !c.shouldRetryDNSFallback(err) {
+		return nil, err, false
+	}
+
+	servers := dnsFallbackServers()
+	if len(servers) == 0 {
+		return nil, err, false
+	}
+
+	fallbackConfig := c.config
+	fallbackConfig.DNSServers = servers
+	fallbackConfig.PreferGoDNS = true
+
+	fallbackClient, clientErr := NewClient(fallbackConfig)
+	if clientErr != nil {
+		return nil, c.formatBootstrapError(ctx, clientErr), true
+	}
+
+	response, reqErr := fallbackClient.bootstrapOnce(ctx, req)
+	if reqErr != nil {
+		reqErr = withDNSFallbackDetails(reqErr, servers)
+		return nil, fallbackClient.formatBootstrapError(ctx, reqErr), true
+	}
+
+	return response, nil, true
+}
+
+func (c *Client) shouldRetryDNSFallback(err error) bool {
+	if runtime.GOOS != "android" {
+		return false
+	}
+	if c.config.PreferGoDNS || len(c.config.DNSServers) > 0 {
+		return false
+	}
+
+	var structuredErr *errors.Error
+	if !stderrors.As(err, &structuredErr) {
+		return false
+	}
+	if structuredErr.Details == nil {
+		return false
+	}
+	if structuredErr.Details["dns_error"] == "" &&
+		!strings.Contains(strings.ToLower(structuredErr.Message), "resolve host") {
+		return false
+	}
+
+	dnsServer := structuredErr.Details["dns_server"]
+	if dnsServer == "" {
+		return true
+	}
+
+	return dnsServerIsLoopback(dnsServer)
 }
 
 func (c *Client) enhanceBootstrapError(ctx context.Context, err error) error {
diff --git a/shared/bootstrap/dns_fallback.go b/shared/bootstrap/dns_fallback.go
new file mode 100644
index 0000000..7af41f2
--- /dev/null
+++ b/shared/bootstrap/dns_fallback.go
@@ -0,0 +1,101 @@
+package bootstrap
+
+import (
+	stderrors "errors"
+	"net"
+	"strings"
+
+	"github.com/expanso-io/expanso/lib/errors"
+)
+
+func dnsFallbackServers() []string {
+	candidates := []string{}
+
+	candidates = append(candidates, androidDNSServers()...)
+
+	if contents, _, err := readResolvConf(); err == nil {
+		candidates = append(candidates, parseResolvConf(contents)...)
+	}
+
+	return filterDNSServers(candidates)
+}
+
+func androidDNSServers() []string {
+	entries := androidDNSProps()
+	if len(entries) == 0 {
+		return nil
+	}
+
+	servers := []string{}
+	for _, entry := range entries {
+		parts := strings.SplitN(entry, "=", 2)
+		if len(parts) != 2 {
+			continue
+		}
+		server := strings.TrimSpace(parts[1])
+		if server == "" {
+			continue
+		}
+		servers = append(servers, server)
+	}
+	return servers
+}
+
+func filterDNSServers(servers []string) []string {
+	if len(servers) == 0 {
+		return nil
+	}
+
+	filtered := []string{}
+	seen := map[string]struct{}{}
+	for _, server := range servers {
+		server = strings.TrimSpace(server)
+		if server == "" {
+			continue
+		}
+		host := dnsServerHost(server)
+		if host == "" || isLoopback(host) {
+			continue
+		}
+		if _, ok := seen[server]; ok {
+			continue
+		}
+		seen[server] = struct{}{}
+		filtered = append(filtered, server)
+	}
+
+	return filtered
+}
+
+func dnsServerIsLoopback(addr string) bool {
+	return isLoopback(dnsServerHost(addr))
+}
+
+func dnsServerHost(addr string) string {
+	if addr == "" {
+		return ""
+	}
+	if host, _, err := net.SplitHostPort(addr); err == nil {
+		return host
+	}
+	if strings.HasPrefix(addr, "[") {
+		trimmed := strings.TrimPrefix(addr, "[")
+		if idx := strings.Index(trimmed, "]"); idx >= 0 {
+			return trimmed[:idx]
+		}
+	}
+	return addr
+}
+
+func withDNSFallbackDetails(err error, servers []string) error {
+	if err == nil || len(servers) == 0 {
+		return err
+	}
+	var structuredErr *errors.Error
+	if !stderrors.As(err, &structuredErr) {
+		return err
+	}
+	updated := structuredErr.Copy()
+	updated = updated.WithDetail("dns_override", strings.Join(servers, ", "))
+	return updated
+}
diff --git a/shared/http/client.go b/shared/http/client.go
index 8484abb..c2cdf0f 100644
--- a/shared/http/client.go
+++ b/shared/http/client.go
@@ -4,6 +4,7 @@ import (
 	"context"
 	"crypto/tls"
 	"net"
+	"strings"
 	"time"
 
 	"github.com/expanso-io/expanso/shared/version"
@@ -59,11 +60,16 @@ func NewClient(config Config) (*req.Client, error) {
 		client.SetProxy(nil)
 	}
 
-	// Force IPv4 connections if requested
-	if config.ForceIPv4 {
-		client.SetDial(func(ctx context.Context, network, addr string) (net.Conn, error) {
-			dialer := net.Dialer{Timeout: config.Timeout}
-			return dialer.DialContext(ctx, "tcp4", addr)
+	dialer := buildDialer(config)
+
+	// Force IPv4 connections if requested (or provide custom resolver)
+	if config.ForceIPv4 || dialer.Resolver != nil {
+		network := "tcp"
+		if config.ForceIPv4 {
+			network = "tcp4"
+		}
+		client.SetDial(func(ctx context.Context, _, addr string) (net.Conn, error) {
+			return dialer.DialContext(ctx, network, addr)
 		})
 	}
 
@@ -83,3 +89,92 @@ func NewClient(config Config) (*req.Client, error) {
 
 	return client, nil
 }
+
+func buildDialer(config Config) net.Dialer {
+	dialer := net.Dialer{Timeout: config.Timeout}
+	if !config.PreferGoDNS && len(config.DNSServers) == 0 {
+		return dialer
+	}
+
+	baseDialer := net.Dialer{Timeout: config.Timeout}
+	servers := normalizeDNSServers(config.DNSServers)
+
+	resolver := &net.Resolver{
+		PreferGo: true,
+	}
+	if len(servers) > 0 {
+		resolver.Dial = func(ctx context.Context, network, _ string) (net.Conn, error) {
+			server := servers[0]
+			dnsNetwork := dnsDialNetwork(network, config.ForceIPv4)
+			return baseDialer.DialContext(ctx, dnsNetwork, server)
+		}
+	}
+
+	dialer.Resolver = resolver
+	return dialer
+}
+
+func dnsDialNetwork(network string, forceIPv4 bool) string {
+	network = strings.ToLower(network)
+	switch {
+	case strings.HasPrefix(network, "tcp"):
+		if forceIPv4 {
+			return "tcp4"
+		}
+		return "tcp"
+	case strings.HasPrefix(network, "udp"):
+		if forceIPv4 {
+			return "udp4"
+		}
+		return "udp"
+	default:
+		if forceIPv4 {
+			return "tcp4"
+		}
+		return "tcp"
+	}
+}
+
+func normalizeDNSServers(servers []string) []string {
+	if len(servers) == 0 {
+		return nil
+	}
+
+	normalized := []string{}
+	seen := map[string]struct{}{}
+	for _, server := range servers {
+		server = strings.TrimSpace(server)
+		if server == "" {
+			continue
+		}
+		addr := normalizeDNSServerAddr(server)
+		if addr == "" {
+			continue
+		}
+		if _, ok := seen[addr]; ok {
+			continue
+		}
+		seen[addr] = struct{}{}
+		normalized = append(normalized, addr)
+	}
+	return normalized
+}
+
+func normalizeDNSServerAddr(server string) string {
+	if server == "" {
+		return ""
+	}
+	if host, port, err := net.SplitHostPort(server); err == nil {
+		if port == "" {
+			port = "53"
+		}
+		return net.JoinHostPort(host, port)
+	}
+	if ip := net.ParseIP(server); ip != nil {
+		return net.JoinHostPort(server, "53")
+	}
+	if strings.Count(server, ":") >= 2 {
+		return net.JoinHostPort(server, "53")
+	}
+	return net.JoinHostPort(server, "53")
+}
diff --git a/shared/http/config.go b/shared/http/config.go
index fe74960..af9f7f0 100644
--- a/shared/http/config.go
+++ b/shared/http/config.go
@@ -34,6 +34,12 @@ type Config struct {
 	// ForceIPv4 forces IPv4 for TCP connections (useful on networks with broken IPv6)
 	ForceIPv4 bool
 
+	// PreferGoDNS forces the Go DNS resolver (useful on platforms with broken system DNS)
+	PreferGoDNS bool
+
+	// DNSServers overrides DNS resolution to use the provided servers (e.g. 8.8.8.8, 1.1.1.1)
+	DNSServers []string
+
 	// Auth configuration
 	Auth AuthConfig
 }
-- 
2.52.0

