diff --git a/edge/cmd/commands/bootstrap.go b/edge/cmd/commands/bootstrap.go
index 8e8b373d..b8774ffa 100644
--- a/edge/cmd/commands/bootstrap.go
+++ b/edge/cmd/commands/bootstrap.go
@@ -22,6 +22,8 @@ type bootstrapConfig struct {
 	DataDir        string
 	Force          bool
 	Insecure       bool
+	NoProxy        bool
+	ForceIPv4      bool
 }
 
 // NewBootstrapCommand creates the bootstrap command
@@ -95,6 +97,8 @@ Examples:
 	cmd.Flags().StringVarP(&cfg.BootstrapURL, "url", "u", "", "Bootstrap service URL (advanced)")
 	cmd.Flags().BoolVarP(&cfg.Force, "force", "f", false, "Force re-bootstrap even if already bootstrapped")
 	cmd.Flags().BoolVarP(&cfg.Insecure, "insecure", "k", false, "Skip TLS certificate verification")
+	cmd.Flags().BoolVar(&cfg.NoProxy, "no-proxy", false, "Disable HTTP proxy usage for bootstrap requests")
+	cmd.Flags().BoolVar(&cfg.ForceIPv4, "force-ipv4", false, "Force IPv4 for bootstrap requests (useful on networks with broken IPv6)")
 
 	cmd.PersistentFlags().StringSliceVarP(&cfg.ConfigPaths, "config", "c", nil, "Paths to configuration files or directories")
 	cmd.Flags().StringVar(&cfg.DataDir, "data-dir", "", "Data directory path")
@@ -132,11 +136,15 @@ func runBootstrap(cmd *cobra.Command, cfg *bootstrapConfig) error {
 	token := flags.ResolveBootstrapToken(cfg.BootstrapToken)
 	url := flags.ResolveBootstrapURL(cfg.BootstrapURL)
 	insecure := flags.ResolveBootstrapInsecure(cfg.Insecure)
+	disableProxy := flags.ResolveBootstrapNoProxy(cfg.NoProxy)
+	forceIPv4 := flags.ResolveBootstrapForceIPv4(cfg.ForceIPv4)
 	_, err = bootstrapService.Bootstrap(ctx, bootstrap.BootstrapOptions{
-		Token:    token,
-		URL:      url,
-		Force:    cfg.Force,
-		Insecure: insecure,
+		Token:        token,
+		URL:          url,
+		Force:        cfg.Force,
+		Insecure:     insecure,
+		DisableProxy: disableProxy,
+		ForceIPv4:    forceIPv4,
 	})
 	if err != nil {
 		// Handle already bootstrapped case gracefully
diff --git a/edge/cmd/commands/run.go b/edge/cmd/commands/run.go
index 937a8d1b..802c32b8 100644
--- a/edge/cmd/commands/run.go
+++ b/edge/cmd/commands/run.go
@@ -96,7 +96,15 @@ func runServiceDirectly(cmd *cobra.Command, cfg *flags.ServiceRunConfig) error {
 		return err
 	}
 
-	if err = ensureRegistered(ctx, cfg.GetBootstrapToken(), cfg.GetBootstrapURL(), cfg.GetBootstrapInsecure(), configManager); err != nil {
+	if err = ensureRegistered(
+		ctx,
+		cfg.GetBootstrapToken(),
+		cfg.GetBootstrapURL(),
+		cfg.GetBootstrapInsecure(),
+		cfg.GetBootstrapNoProxy(),
+		cfg.GetBootstrapForceIPv4(),
+		configManager,
+	); err != nil {
 		return err
 	}
 
@@ -157,7 +165,15 @@ func runWithSupervisor(cmd *cobra.Command, cfg *flags.ServiceRunConfig) error {
 		return err
 	}
 
-	if err = ensureRegistered(ctx, cfg.GetBootstrapToken(), cfg.GetBootstrapURL(), cfg.GetBootstrapInsecure(), configManager); err != nil {
+	if err = ensureRegistered(
+		ctx,
+		cfg.GetBootstrapToken(),
+		cfg.GetBootstrapURL(),
+		cfg.GetBootstrapInsecure(),
+		cfg.GetBootstrapNoProxy(),
+		cfg.GetBootstrapForceIPv4(),
+		configManager,
+	); err != nil {
 		return err
 	}
 
@@ -215,7 +231,15 @@ func loadConfig(cmd *cobra.Command, configPaths []string) (interfaces.EdgeConfig
 	return configManager, loader, nil
 }
 
-func ensureRegistered(ctx context.Context, token, url string, insecure bool, configManager interfaces.EdgeConfigManager) error {
+func ensureRegistered(
+	ctx context.Context,
+	token string,
+	url string,
+	insecure bool,
+	disableProxy bool,
+	forceIPv4 bool,
+	configManager interfaces.EdgeConfigManager,
+) error {
 	// If explicit local mode, skip bootstrap
 	if configManager.Current().LocalMode {
 		return nil
@@ -224,9 +248,11 @@ func ensureRegistered(ctx context.Context, token, url string, insecure bool, con
 	// Not in local mode - attempt bootstrap
 	bootstrapService := bootstrap.NewBootstrapService(configManager, nil)
 	_, err := bootstrapService.EnsureBootstrapped(ctx, bootstrap.BootstrapOptions{
-		Token:    token,
-		URL:      url,
-		Insecure: insecure,
+		Token:        token,
+		URL:          url,
+		Insecure:     insecure,
+		DisableProxy: disableProxy,
+		ForceIPv4:    forceIPv4,
 	})
 	if err != nil {
 		return errors.Wrap(err, "failed to connect edge node")
diff --git a/edge/cmd/flags/service.go b/edge/cmd/flags/service.go
index 0d15345a..69ea6e3a 100644
--- a/edge/cmd/flags/service.go
+++ b/edge/cmd/flags/service.go
@@ -9,11 +9,22 @@ import (
 
 // Bootstrap environment variable names
 const (
-	EnvBootstrapToken    = "EXPANSO_EDGE_BOOTSTRAP_TOKEN" //nolint:gosec // G101 false positive - env var name, not a credential
-	EnvBootstrapURL      = "EXPANSO_EDGE_BOOTSTRAP_URL"
-	EnvBootstrapInsecure = "EXPANSO_EDGE_BOOTSTRAP_INSECURE"
+	EnvBootstrapToken     = "EXPANSO_EDGE_BOOTSTRAP_TOKEN" //nolint:gosec // G101 false positive - env var name, not a credential
+	EnvBootstrapURL       = "EXPANSO_EDGE_BOOTSTRAP_URL"
+	EnvBootstrapInsecure  = "EXPANSO_EDGE_BOOTSTRAP_INSECURE"
+	EnvBootstrapNoProxy   = "EXPANSO_EDGE_BOOTSTRAP_NO_PROXY"
+	EnvBootstrapForceIPv4 = "EXPANSO_EDGE_BOOTSTRAP_FORCE_IPV4"
 )
 
+const (
+	envBoolTrue = "true"
+	envBoolOne  = "1"
+)
+
+func envBool(value string) bool {
+	return value == envBoolTrue || value == envBoolOne
+}
+
 // ResolveBootstrapToken returns the bootstrap token, checking CLI value first then env var
 func ResolveBootstrapToken(cliValue string) string {
 	if cliValue != "" {
@@ -35,7 +46,23 @@ func ResolveBootstrapInsecure(cliValue bool) bool {
 	if cliValue {
 		return true
 	}
-	return os.Getenv(EnvBootstrapInsecure) == "true" || os.Getenv(EnvBootstrapInsecure) == "1"
+	return envBool(os.Getenv(EnvBootstrapInsecure))
+}
+
+// ResolveBootstrapNoProxy returns true when proxy usage should be disabled
+func ResolveBootstrapNoProxy(cliValue bool) bool {
+	if cliValue {
+		return true
+	}
+	return envBool(os.Getenv(EnvBootstrapNoProxy))
+}
+
+// ResolveBootstrapForceIPv4 returns true when bootstrap should force IPv4
+func ResolveBootstrapForceIPv4(cliValue bool) bool {
+	if cliValue {
+		return true
+	}
+	return envBool(os.Getenv(EnvBootstrapForceIPv4))
 }
 
 // ServiceConfig holds all configuration for the service command
@@ -50,9 +77,11 @@ type ServiceConfig struct {
 	Verbose      bool
 
 	// Bootstrap
-	BootstrapToken    string
-	BootstrapURL      string
-	BootstrapInsecure bool
+	BootstrapToken     string
+	BootstrapURL       string
+	BootstrapInsecure  bool
+	BootstrapNoProxy   bool
+	BootstrapForceIPv4 bool
 
 	// Convenience flags
 	LocalMode bool
@@ -73,6 +102,16 @@ func (c *ServiceConfig) GetBootstrapInsecure() bool {
 	return ResolveBootstrapInsecure(c.BootstrapInsecure)
 }
 
+// GetBootstrapNoProxy returns whether bootstrap should skip proxy usage
+func (c *ServiceConfig) GetBootstrapNoProxy() bool {
+	return ResolveBootstrapNoProxy(c.BootstrapNoProxy)
+}
+
+// GetBootstrapForceIPv4 returns whether bootstrap should force IPv4
+func (c *ServiceConfig) GetBootstrapForceIPv4() bool {
+	return ResolveBootstrapForceIPv4(c.BootstrapForceIPv4)
+}
+
 // ServiceRunConfig holds all configuration for the service run command
 type ServiceRunConfig struct {
 	ServiceConfig
@@ -114,6 +153,18 @@ func AddServiceConfigFlags(cmd *cobra.Command, cfg *ServiceConfig) {
 		false,
 		"Skip TLS certificate verification for bootstrap",
 	)
+	cmd.Flags().BoolVar(
+		&cfg.BootstrapNoProxy,
+		"bootstrap-no-proxy",
+		false,
+		"Disable HTTP proxy usage for bootstrap requests",
+	)
+	cmd.Flags().BoolVar(
+		&cfg.BootstrapForceIPv4,
+		"bootstrap-force-ipv4",
+		false,
+		"Force IPv4 for bootstrap requests (useful on networks with broken IPv6)",
+	)
 
 	// Convenience flags
 	cmd.Flags().BoolVar(&cfg.LocalMode, "local", false, "Run in local mode (no control plane connection)")
diff --git a/edge/cmd/flags/service_test.go b/edge/cmd/flags/service_test.go
index 38daf1ef..37e2e8ba 100644
--- a/edge/cmd/flags/service_test.go
+++ b/edge/cmd/flags/service_test.go
@@ -73,3 +73,135 @@ func TestResolveBootstrapInsecure(t *testing.T) {
 		})
 	}
 }
+
+func TestResolveBootstrapNoProxy(t *testing.T) {
+	tests := []struct {
+		name     string
+		cliValue bool
+		envValue string
+		expected bool
+	}{
+		{
+			name:     "CLI true overrides everything",
+			cliValue: true,
+			envValue: "",
+			expected: true,
+		},
+		{
+			name:     "CLI true overrides env false",
+			cliValue: true,
+			envValue: "false",
+			expected: true,
+		},
+		{
+			name:     "CLI false, env true returns true",
+			cliValue: false,
+			envValue: "true",
+			expected: true,
+		},
+		{
+			name:     "CLI false, env 1 returns true",
+			cliValue: false,
+			envValue: "1",
+			expected: true,
+		},
+		{
+			name:     "CLI false, env false returns false",
+			cliValue: false,
+			envValue: "false",
+			expected: false,
+		},
+		{
+			name:     "CLI false, env empty returns false",
+			cliValue: false,
+			envValue: "",
+			expected: false,
+		},
+		{
+			name:     "CLI false, env random string returns false",
+			cliValue: false,
+			envValue: "yes",
+			expected: false,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if tt.envValue != "" {
+				os.Setenv(EnvBootstrapNoProxy, tt.envValue)
+				defer os.Unsetenv(EnvBootstrapNoProxy)
+			} else {
+				os.Unsetenv(EnvBootstrapNoProxy)
+			}
+
+			result := ResolveBootstrapNoProxy(tt.cliValue)
+			assert.Equal(t, tt.expected, result)
+		})
+	}
+}
+
+func TestResolveBootstrapForceIPv4(t *testing.T) {
+	tests := []struct {
+		name     string
+		cliValue bool
+		envValue string
+		expected bool
+	}{
+		{
+			name:     "CLI true overrides everything",
+			cliValue: true,
+			envValue: "",
+			expected: true,
+		},
+		{
+			name:     "CLI true overrides env false",
+			cliValue: true,
+			envValue: "false",
+			expected: true,
+		},
+		{
+			name:     "CLI false, env true returns true",
+			cliValue: false,
+			envValue: "true",
+			expected: true,
+		},
+		{
+			name:     "CLI false, env 1 returns true",
+			cliValue: false,
+			envValue: "1",
+			expected: true,
+		},
+		{
+			name:     "CLI false, env false returns false",
+			cliValue: false,
+			envValue: "false",
+			expected: false,
+		},
+		{
+			name:     "CLI false, env empty returns false",
+			cliValue: false,
+			envValue: "",
+			expected: false,
+		},
+		{
+			name:     "CLI false, env random string returns false",
+			cliValue: false,
+			envValue: "yes",
+			expected: false,
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			if tt.envValue != "" {
+				os.Setenv(EnvBootstrapForceIPv4, tt.envValue)
+				defer os.Unsetenv(EnvBootstrapForceIPv4)
+			} else {
+				os.Unsetenv(EnvBootstrapForceIPv4)
+			}
+
+			result := ResolveBootstrapForceIPv4(tt.cliValue)
+			assert.Equal(t, tt.expected, result)
+		})
+	}
+}
diff --git a/shared/bootstrap/client.go b/shared/bootstrap/client.go
index 4784a0d3..81d8c3b1 100644
--- a/shared/bootstrap/client.go
+++ b/shared/bootstrap/client.go
@@ -52,6 +52,12 @@ type ClientConfig struct {
 
 	// InsecureSkipVerify skips TLS certificate verification
 	InsecureSkipVerify bool
+
+	// DisableProxy disables proxy usage for bootstrap requests
+	DisableProxy bool
+
+	// ForceIPv4 forces IPv4 for bootstrap requests
+	ForceIPv4 bool
 }
 
 // NewClient creates a new bootstrap client
@@ -75,6 +81,8 @@ func NewClient(config ClientConfig) (*Client, error) {
 		Timeout:            config.Timeout,
 		Debug:              config.Debug,
 		InsecureSkipVerify: config.InsecureSkipVerify,
+		DisableProxy:       config.DisableProxy,
+		ForceIPv4:          config.ForceIPv4,
 		Auth: corehttp.AuthConfig{
 			Token: config.Token,
 		},
diff --git a/shared/bootstrap/service.go b/shared/bootstrap/service.go
index 295fa5e2..c07d3102 100644
--- a/shared/bootstrap/service.go
+++ b/shared/bootstrap/service.go
@@ -93,7 +93,7 @@ func (s *BootstrapService) Bootstrap(ctx context.Context, opts BootstrapOptions)
 
 	// Perform bootstrap with provided token
 	s.logger.Debug("Attempting bootstrap with provided token")
-	return s.doBootstrap(ctx, opts.Token, opts.URL, opts.Insecure, "bootstrap")
+	return s.doBootstrap(ctx, opts.Token, opts.URL, opts.Insecure, opts.DisableProxy, opts.ForceIPv4, "bootstrap")
 }
 
 // Refresh refreshes existing credentials using the saved JWT
@@ -107,7 +107,7 @@ func (s *BootstrapService) Refresh(ctx context.Context, insecure bool) (*Credent
 	}
 
 	s.logger.Debug("Attempting refresh with existing JWT")
-	return s.doBootstrap(ctx, info.UserJWT, info.ConnectionConfig.RefreshAddress, insecure, "refresh")
+	return s.doBootstrap(ctx, info.UserJWT, info.ConnectionConfig.RefreshAddress, insecure, false, false, "refresh")
 }
 
 // EnsureBootstrapped checks if bootstrap is needed and performs it if necessary
@@ -145,10 +145,12 @@ func (s *BootstrapService) EnsureBootstrapped(ctx context.Context, opts Bootstra
 	}
 
 	_, err := s.Bootstrap(ctx, BootstrapOptions{
-		Token:    opts.Token,
-		URL:      opts.URL,
-		Force:    false,
-		Insecure: opts.Insecure,
+		Token:        opts.Token,
+		URL:          opts.URL,
+		Force:        false,
+		Insecure:     opts.Insecure,
+		DisableProxy: opts.DisableProxy,
+		ForceIPv4:    opts.ForceIPv4,
 	})
 	if err != nil {
 		// Handle already bootstrapped case gracefully
@@ -171,6 +173,8 @@ func (s *BootstrapService) doBootstrap(
 	token,
 	bootstrapURL string,
 	insecure bool,
+	disableProxy bool,
+	forceIPv4 bool,
 	operation string,
 ) (*CredentialInfo, error) {
 	// Use default URL if none provided
@@ -183,6 +187,8 @@ func (s *BootstrapService) doBootstrap(
 		BaseURL:            bootstrapURL,
 		Token:              token,
 		InsecureSkipVerify: insecure,
+		DisableProxy:       disableProxy,
+		ForceIPv4:          forceIPv4,
 	})
 	if err != nil {
 		return nil, errors.Wrap(err, "failed to create bootstrap client")
diff --git a/shared/bootstrap/types.go b/shared/bootstrap/types.go
index 3cee47fd..80334876 100644
--- a/shared/bootstrap/types.go
+++ b/shared/bootstrap/types.go
@@ -30,6 +30,12 @@ type BootstrapOptions struct {
 	Force bool
 	// Insecure skips TLS certificate verification
 	Insecure bool
+
+	// DisableProxy disables proxy usage for bootstrap requests
+	DisableProxy bool
+
+	// ForceIPv4 forces IPv4 for bootstrap requests
+	ForceIPv4 bool
 }
 
 // BootstrapResponse is returned by the bootstrap service
diff --git a/shared/http/client.go b/shared/http/client.go
index a4454952..8484abba 100644
--- a/shared/http/client.go
+++ b/shared/http/client.go
@@ -1,7 +1,9 @@
 package http
 
 import (
+	"context"
 	"crypto/tls"
+	"net"
 	"time"
 
 	"github.com/expanso-io/expanso/shared/version"
@@ -52,6 +54,19 @@ func NewClient(config Config) (*req.Client, error) {
 			})
 	}
 
+	// Disable proxy usage if requested
+	if config.DisableProxy {
+		client.SetProxy(nil)
+	}
+
+	// Force IPv4 connections if requested
+	if config.ForceIPv4 {
+		client.SetDial(func(ctx context.Context, network, addr string) (net.Conn, error) {
+			dialer := net.Dialer{Timeout: config.Timeout}
+			return dialer.DialContext(ctx, "tcp4", addr)
+		})
+	}
+
 	// Configure debug mode
 	if config.Debug {
 		client.EnableDebugLog()
diff --git a/shared/http/config.go b/shared/http/config.go
index 00c75192..fe749605 100644
--- a/shared/http/config.go
+++ b/shared/http/config.go
@@ -28,6 +28,12 @@ type Config struct {
 	// Debug enables debug logging and request/response dumping (default: false)
 	Debug bool
 
+	// DisableProxy disables HTTP proxy usage, ignoring HTTP_PROXY/HTTPS_PROXY/NO_PROXY
+	DisableProxy bool
+
+	// ForceIPv4 forces IPv4 for TCP connections (useful on networks with broken IPv6)
+	ForceIPv4 bool
+
 	// Auth configuration
 	Auth AuthConfig
 }
